: comment Compiled using Eoghan's flap to clac compiler https://github.com/Eoghanmc22/flap-compiler ;

: comment flap source code:
    // Conways Game of Life
    
    const int DIMENSION = 7;
    const int LEN = DIMENSION * DIMENSION;
    const int SEED_HIGH = 0b0000000000000000100;
    const int SEED_LOW = 0b000011000010100000000000000000;
    
    // Convets a logical position into a bit index
    int get_cell_index(int x, int y) {
      x + DIMENSION * y
    }
    
    // Returns the status of a cell
    // Returns 1 if the cell at index x, y is alive
    // Returns 0 otherwise
    int get_cell_state(int data_high, int data_low, int x, int y) {
      int index = get_cell_index(x, y);
    
      if (index >= 30) {
        int index = index - 30;
        (data_high >> index) & 1
      } else {
        (data_low >> index) & 1
      }
    }
    
    // Wrapping offset of logical positions
    // Adds `by` to `pos` mod `DIMENSION`
    int offset(int pos, int by) {
      if (by >= 0) {
        (pos + by) % DIMENSION
      } else {
        (pos + DIMENSION + by) % DIMENSION
      }
    }
    
    // Bit index to logical x position
    int idx_to_x(int idx) {
      idx % DIMENSION
    }
    
    // Bit index to logical y position
    int idx_to_y(int idx) {
      idx / DIMENSION
    }
    
    // Calculates the next state of a cell using the rules of Conways Game of Life
    int update_cell(int data_high, int data_low, int x, int y) {
      int neighbors = 
              get_cell_state(data_high, data_low, offset(x, -1), offset(y, -1))
              + get_cell_state(data_high, data_low, offset(x, 0), offset(y, -1))
              + get_cell_state(data_high, data_low, offset(x, 1), offset(y, -1))
              + get_cell_state(data_high, data_low, offset(x, -1), offset(y, 0))
              + get_cell_state(data_high, data_low, offset(x, 1), offset(y, 0))
              + get_cell_state(data_high, data_low, offset(x, -1), offset(y, 1))
              + get_cell_state(data_high, data_low, offset(x, 0), offset(y, 1))
              + get_cell_state(data_high, data_low, offset(x, 1), offset(y, 1));
    
      int is_alive = get_cell_state(data_high, data_low, x, y);
    
      if (neighbors < 2) {
        0
      } else if (neighbors == 2) {
        is_alive
      } else if (neighbors == 3) {
        1
      } else {
        0
      }
    }
    
    // Compute the next low order bits of the game state
    int compute_next_data_low(int last_data_high, int last_data_low) {
      int compute_next_data_low(int last_data_high, int last_data_low, int next_data_low, int idx) {
        if (idx < 30) {
          int x = idx_to_x(idx);
          int y = idx_to_y(idx);
    
          int next_data_low = next_data_low + (update_cell(last_data_high, last_data_low, x, y) << idx);
    
          compute_next_data_low(last_data_high, last_data_low, next_data_low, idx + 1)
        } else {
          next_data_low
        }
      }
    
      compute_next_data_low(last_data_high, last_data_low, 0, 0)
    }
    
    // Compute the next high order bits of the game state
    int compute_next_data_high(int last_data_high, int last_data_low) {
      int compute_next_data_high(int last_data_high, int last_data_low, int next_data_high, int idx) {
        if (idx + 30 < LEN) {
          int x = idx_to_x(idx + 30);
          int y = idx_to_y(idx + 30);
    
          int next_data_high = next_data_high + (update_cell(last_data_high, last_data_low, x, y) << idx);
    
          compute_next_data_high(last_data_high, last_data_low, next_data_high, idx + 1)
        } else {
          next_data_high
        }
      }
    
      compute_next_data_high(last_data_high, last_data_low, 0, 0)
    }
    
    // Compute the integer used to print a game row in a somewhat human readable way
    int make_decimal_row(int data_high, int data_low, int y) {
      int make_decimal_row(int data_high, int data_low, int x, int y, int row) {
        if (x < DIMENSION) {
          // int row = row + (1 + 7 * get_cell_state(data_high, data_low, x, y)) * (10 ** x);
          int row = row + (8 - 7 * get_cell_state(data_high, data_low, x, y)) * (10 ** x);
        
          make_decimal_row(data_high, data_low, x + 1, y, row)
        } else {
          row
        }
      }
    
      make_decimal_row(data_high, data_low, 0, y, 0)
    }
    
    // Print the whole game state
    void print_game(int data_high, int data_low) {
      void print_game(int data_high, int data_low, int y) {
        if (y < DIMENSION) {
          int row = make_decimal_row(data_high, data_low, y);
    
          print(row);
        
          print_game(data_high, data_low, y + 1);
        }
      }
    
      print_game(data_high, data_low, 0)
    }
    
    // The recursive game loop
    void game_loop(int data_high, int data_low) {
      print_game(data_high, data_low);
    
      // Emulate new lines
      print(0);
      print(0);
      print(0);
    
      int next_data_low = compute_next_data_low(data_high, data_low);
      int next_data_high = compute_next_data_high(data_high, data_low);
    
      // Recursion goes brrrr
      game_loop(next_data_high, next_data_low)
    }
    
    game_loop(SEED_HIGH, SEED_LOW);
;

: comment Start Definitions ;
: drop_range_inner 1 pick 2 pick if 2 12 skip drop drop -1 + swap -1 + swap drop_range_outer 0 32 skip % swap 2 / swap 1 pick if 1 3 skip drop 12 skip + if drop_range_inner 4 skip drop_range_inner -1 5 skip 1 2 skip drop_range_inner 0 swap 2 * + ;
: drop_range_outer 1 pick if rot 2 skip 19 skip 3 pick if drop_range_inner 0 skip 2 pick if drop 4 skip rot rot 3 skip -1 + drop_range_outer ;
: drop_range drop_range_outer drop drop ;
: func-get_cell_index-30 7 2 pick * 3 pick 2 pick + 1 pick swap drop swap drop swap drop swap drop ;
: func-on_true-32 1 pick 30 - 4 pick 2 pick 2 swap ** / 1 pick 0 2 pick 2 % 1 pick * + 1 pick swap drop swap drop swap drop swap drop swap drop swap drop swap drop ;
: func-on_false-33 2 pick 2 pick 2 swap ** / 1 pick 0 2 pick 2 % 1 pick * + 1 pick swap drop swap drop swap drop swap drop swap drop swap drop ;
: func-get_cell_state-31 2 pick 2 pick func-get_cell_index-30 1 pick 30 < 1 swap - 6 pick 6 pick 4 pick 4 pick if func-on_true-32 1 skip func-on_false-33 swap drop swap drop swap drop swap drop swap drop swap drop ;
: func-on_true-35 1 pick 3 pick + 1 pick 7 % 1 pick swap drop swap drop swap drop swap drop ;
: func-on_false-36 1 pick 7 + 1 pick 4 pick + 1 pick 7 % 1 pick swap drop swap drop swap drop swap drop swap drop ;
: func-offset-34 1 pick 0 < 1 swap - 2 pick 4 pick 3 pick if func-on_true-35 1 skip func-on_false-36 swap drop swap drop swap drop ;
: func-idx_to_x-37 1 pick 7 % 1 pick swap drop swap drop ;
: func-idx_to_y-38 1 pick 7 / 1 pick swap drop swap drop ;
: func-on_true-40 0 swap drop swap drop ;
: func-on_true-42 2 pick swap drop swap drop ;
: func-on_true-44 1 swap drop swap drop ;
: func-on_false-45 0 swap drop swap drop ;
: func-on_false-43 1 pick 3 - if 0 1 skip 1 3 pick 3 pick 3 pick if func-on_true-44 1 skip func-on_false-45 swap drop swap drop swap drop ;
: func-on_false-41 1 pick 2 - if 0 1 skip 1 3 pick 3 pick 3 pick if func-on_true-42 1 skip func-on_false-43 swap drop swap drop swap drop ;
: func-update_cell-39 2 pick -1 func-offset-34 2 pick -1 func-offset-34 6 pick 6 pick 4 pick 4 pick func-get_cell_state-31 5 pick 0 func-offset-34 5 pick -1 func-offset-34 9 pick 9 pick 4 pick 4 pick func-get_cell_state-31 4 pick 2 pick + 9 pick 1 func-offset-34 9 pick -1 func-offset-34 13 pick 13 pick 4 pick 4 pick func-get_cell_state-31 4 pick 2 pick + 13 pick -1 func-offset-34 13 pick 0 func-offset-34 17 pick 17 pick 4 pick 4 pick func-get_cell_state-31 4 pick 2 pick + 17 pick 1 func-offset-34 17 pick 0 func-offset-34 21 pick 21 pick 4 pick 4 pick func-get_cell_state-31 4 pick 2 pick + 21 pick -1 func-offset-34 21 pick 1 func-offset-34 25 pick 25 pick 4 pick 4 pick func-get_cell_state-31 4 pick 2 pick + 25 pick 0 func-offset-34 25 pick 1 func-offset-34 29 pick 29 pick 4 pick 4 pick func-get_cell_state-31 4 pick 2 pick + 29 pick 1 func-offset-34 29 pick 1 func-offset-34 33 pick 33 pick 4 pick 4 pick func-get_cell_state-31 4 pick 2 pick + 35 pick 35 pick 35 pick 35 pick func-get_cell_state-31 2 pick 2 < 2 pick 4 pick 3 pick if func-on_true-40 1 skip func-on_false-41 swap drop swap drop swap drop swap drop swap drop swap drop swap drop swap drop swap drop swap drop swap drop swap drop swap drop swap drop swap drop swap drop swap drop swap drop swap drop swap drop swap drop swap drop swap drop swap drop swap drop swap drop swap drop swap drop swap drop swap drop swap drop swap drop swap drop swap drop swap drop swap drop swap drop ;
: func-on_true-48 4 pick func-idx_to_x-37 5 pick func-idx_to_y-38 5 pick 5 pick 4 pick 4 pick func-update_cell-39 1 pick 8 pick 2 swap ** * 5 pick 2 pick + 9 pick 1 + 9 pick 9 pick 4 pick 4 pick func-compute_next_data_low-47 swap drop swap drop swap drop swap drop swap drop swap drop swap drop swap drop swap drop swap drop ;
: func-on_false-49 1 pick swap drop swap drop swap drop swap drop ;
: func-compute_next_data_low-47 1 pick 30 < 2 pick 6 pick 6 pick 6 pick 5 pick if func-on_true-48 1 skip func-on_false-49 swap drop swap drop swap drop swap drop swap drop ;
: func-compute_next_data_low-46 2 pick 2 pick 0 0 func-compute_next_data_low-47 swap drop swap drop ;
: func-on_true-52 4 pick 30 + 1 pick func-idx_to_x-37 6 pick 30 + 1 pick func-idx_to_y-38 7 pick 7 pick 5 pick 4 pick func-update_cell-39 1 pick 10 pick 2 swap ** * 7 pick 2 pick + 11 pick 1 + 11 pick 11 pick 4 pick 4 pick func-compute_next_data_high-51 swap drop swap drop swap drop swap drop swap drop swap drop swap drop swap drop swap drop swap drop swap drop swap drop ;
: func-on_false-53 1 pick swap drop swap drop swap drop swap drop ;
: func-compute_next_data_high-51 1 pick 30 + 1 pick 49 < 3 pick 7 pick 7 pick 7 pick 5 pick if func-on_true-52 1 skip func-on_false-53 swap drop swap drop swap drop swap drop swap drop swap drop ;
: func-compute_next_data_high-50 2 pick 2 pick 0 0 func-compute_next_data_high-51 swap drop swap drop ;
: func-on_true-56 5 pick 5 pick 4 pick 4 pick func-get_cell_state-31 7 2 pick * 8 2 pick - 10 6 pick ** 2 pick 2 pick * 8 pick 2 pick + 8 pick 1 + 12 pick 12 pick 3 pick 11 pick 6 pick func-make_decimal_row-55 swap drop swap drop swap drop swap drop swap drop swap drop swap drop swap drop swap drop swap drop swap drop swap drop ;
: func-on_false-57 3 pick swap drop swap drop swap drop swap drop swap drop ;
: func-make_decimal_row-55 3 pick 7 < 6 pick 6 pick 4 pick 7 pick 7 pick 6 pick if func-on_true-56 1 skip func-on_false-57 swap drop swap drop swap drop swap drop swap drop swap drop ;
: func-make_decimal_row-54 3 pick 3 pick 0 4 pick 0 func-make_decimal_row-55 swap drop swap drop swap drop ;
: func-on_true-60 3 pick 3 pick 3 pick func-make_decimal_row-54 1 pick print 2 pick 1 + 5 pick 5 pick 3 pick func-print_game-59 drop drop drop drop drop ;
: func-print_game-59 1 pick 7 < 4 pick 4 pick 4 pick 4 pick if func-on_true-60 3 skip drop drop drop drop drop drop drop ;
: func-print_game-58 2 pick 2 pick 0 func-print_game-59 drop drop ;
: func-game_loop-61 2 pick 2 pick func-print_game-58 0 print 0 print 0 print 2 pick 2 pick func-compute_next_data_low-46 3 pick 3 pick func-compute_next_data_high-50 1 pick 3 pick rot drop rot drop rot drop rot drop func-game_loop-61 ;

: comment Start Main ;
4 50987008 func-game_loop-61