: comment Compiled using Eoghan's flap to clac compiler https://github.com/Eoghanmc22/flap-compiler ;

: comment flap source code:
    // Conways Game of Life
    
    const int DIMENSION = 7;
    //const int LEN = DIMENSION * DIMENSION;
    const int LEN = 49;
    const int SEED_HIGH = 0b0000000000000000100;
    const int SEED_LOW = 0b000011000010100000000000000000;
    
    // Convets a logical position into a bit index
    int get_cell_index(int x, int y) {
      x + DIMENSION * y
    }
    
    // Returns the status of a cell
    // Returns 1 if the cell at index x, y is alive
    // Returns 0 otherwise
    int get_cell_state(int data_high, int data_low, int x, int y) {
      int index = get_cell_index(x, y);
    
      if (index >= 30) {
        int index = index - 30;
        (data_high >> index) & 1
      } else {
        (data_low >> index) & 1
      }
    }
    
    // Wrapping offset of logical positions
    // Adds `by` to `pos` mod `DIMENSION`
    int offset(int pos, int by) {
      if (by >= 0) {
        (pos + by) % DIMENSION
      } else {
        (pos + DIMENSION + by) % DIMENSION
      }
    }
    
    // Bit index to logical x position
    int idx_to_x(int idx) {
      idx % DIMENSION
    }
    
    // Bit index to logical y position
    int idx_to_y(int idx) {
      idx / DIMENSION
    }
    
    // Calculates the next state of a cell using the rules of Conways Game of Life
    int update_cell(int data_high, int data_low, int x, int y) {
      int neighbors = 
              get_cell_state(data_high, data_low, offset(x, -1), offset(y, -1))
              + get_cell_state(data_high, data_low, offset(x, 0), offset(y, -1))
              + get_cell_state(data_high, data_low, offset(x, 1), offset(y, -1))
              + get_cell_state(data_high, data_low, offset(x, -1), offset(y, 0))
              + get_cell_state(data_high, data_low, offset(x, 1), offset(y, 0))
              + get_cell_state(data_high, data_low, offset(x, -1), offset(y, 1))
              + get_cell_state(data_high, data_low, offset(x, 0), offset(y, 1))
              + get_cell_state(data_high, data_low, offset(x, 1), offset(y, 1));
    
      int is_alive = get_cell_state(data_high, data_low, x, y);
    
      if (neighbors < 2) {
        0
      } else if (neighbors == 2) {
        is_alive
      } else if (neighbors == 3) {
        1
      } else {
        0
      }
    }
    
    // Compute the next low order bits of the game state
    int compute_next_data_low(int last_data_high, int last_data_low) {
      int compute_next_data_low(int last_data_high, int last_data_low, int next_data_low, int idx) {
        if (idx < 30) {
          int x = idx_to_x(idx);
          int y = idx_to_y(idx);
    
          int next_data_low = next_data_low + (update_cell(last_data_high, last_data_low, x, y) << idx);
    
          compute_next_data_low(last_data_high, last_data_low, next_data_low, idx + 1)
        } else {
          next_data_low
        }
      }
    
      compute_next_data_low(last_data_high, last_data_low, 0, 0)
    }
    
    // Compute the next high order bits of the game state
    int compute_next_data_high(int last_data_high, int last_data_low) {
      int compute_next_data_high(int last_data_high, int last_data_low, int next_data_high, int idx) {
        if (idx + 30 < LEN) {
          int x = idx_to_x(idx + 30);
          int y = idx_to_y(idx + 30);
    
          int next_data_high = next_data_high + (update_cell(last_data_high, last_data_low, x, y) << idx);
    
          compute_next_data_high(last_data_high, last_data_low, next_data_high, idx + 1)
        } else {
          next_data_high
        }
      }
    
      compute_next_data_high(last_data_high, last_data_low, 0, 0)
    }
    
    // Compute the integer used to print a game row in a somewhat human readable way
    int make_decimal_row(int data_high, int data_low, int y) {
      int make_decimal_row(int data_high, int data_low, int x, int y, int row) {
        if (x < DIMENSION) {
          // int row = row + (1 + 7 * get_cell_state(data_high, data_low, x, y)) * (10 ** x);
          int row = row + (8 - 7 * get_cell_state(data_high, data_low, x, y)) * (10 ** x);
        
          make_decimal_row(data_high, data_low, x + 1, y, row)
        } else {
          row
        }
      }
    
      make_decimal_row(data_high, data_low, 0, y, 0)
    }
    
    // Print the whole game state
    void print_game(int data_high, int data_low) {
      void print_game(int data_high, int data_low, int y) {
        if (y < DIMENSION) {
          int row = make_decimal_row(data_high, data_low, y);
    
          print(row);
        
          print_game(data_high, data_low, y + 1);
        }
      }
    
      print_game(data_high, data_low, 0)
    }
    
    // The recursive game loop
    void game_loop(int data_high, int data_low) {
      print_game(data_high, data_low);
    
      // Emulate new lines
      print(0);
      print(0);
      print(0);
    
      int next_data_low = compute_next_data_low(data_high, data_low);
      int next_data_high = compute_next_data_high(data_high, data_low);
    
      // Recursion goes brrrr
      game_loop(next_data_high, next_data_low)
    }
    
    game_loop(SEED_HIGH, SEED_LOW);
;

: comment Start Definitions ;
: drop_range_inner 1 pick 2 pick if 2 12 skip drop drop -1 + swap -1 + swap drop_range_outer 0 32 skip % swap 2 / swap 1 pick if 1 3 skip drop 12 skip + if drop_range_inner 4 skip drop_range_inner -1 5 skip 1 2 skip drop_range_inner 0 swap 2 * + ;
: drop_range_outer 1 pick if rot 2 skip 19 skip 3 pick if drop_range_inner 0 skip 2 pick if drop 4 skip rot rot 3 skip -1 + drop_range_outer ;
: drop_range drop_range_outer drop drop ;
: func-get_cell_index-23 7 2 pick * 3 pick 2 pick + 1 pick swap drop swap drop swap drop swap drop ;
: func-on_true-25 1 pick 30 - 4 pick 2 pick 2 swap ** / 1 pick 0 2 pick 2 % 1 pick * + 1 pick swap drop swap drop swap drop swap drop swap drop swap drop swap drop ;
: func-on_false-26 2 pick 2 pick 2 swap ** / 1 pick 0 2 pick 2 % 1 pick * + 1 pick swap drop swap drop swap drop swap drop swap drop swap drop ;
: func-get_cell_state-24 2 pick 2 pick func-get_cell_index-23 1 pick 30 rot rot < - 5 pick 5 pick 3 pick 4 pick 4 9 drop_range if func-on_true-25 1 skip func-on_false-26 ;
: func-on_true-28 1 pick 3 pick + 1 pick 7 % 1 pick swap drop swap drop swap drop swap drop ;
: func-on_false-29 1 pick 7 + 1 pick 4 pick + 1 pick 7 % 1 pick swap drop swap drop swap drop swap drop swap drop ;
: func-offset-27 1 pick 0 rot rot < - 1 pick 3 pick 3 pick 3 5 drop_range if func-on_true-28 1 skip func-on_false-29 ;
: func-idx_to_x-30 1 pick 7 % 1 pick swap drop swap drop ;
: func-idx_to_y-31 1 pick 7 / 1 pick swap drop swap drop ;
: func-on_true-33 0 swap drop swap drop ;
: func-on_true-35 2 pick swap drop swap drop ;
: func-on_true-37 1 swap drop swap drop ;
: func-on_false-38 0 swap drop swap drop ;
: func-on_false-36 1 pick 3 - if 0 1 skip 1 3 pick 3 pick 3 pick 3 6 drop_range if func-on_true-37 1 skip func-on_false-38 ;
: func-on_false-34 1 pick 2 - if 0 1 skip 1 3 pick 3 pick 3 pick 3 6 drop_range if func-on_true-35 1 skip func-on_false-36 ;
: func-update_cell-32 1 0 swap - 3 pick 2 pick func-offset-27 1 0 swap - 4 pick 2 pick func-offset-27 8 pick 8 pick 5 pick 4 pick func-get_cell_state-24 7 pick 0 func-offset-27 1 0 swap - 8 pick 2 pick func-offset-27 12 pick 12 pick 5 pick 4 pick func-get_cell_state-24 5 pick 2 pick + 12 pick 1 func-offset-27 1 0 swap - 13 pick 2 pick func-offset-27 17 pick 17 pick 5 pick 4 pick func-get_cell_state-24 5 pick 2 pick + 1 0 swap - 18 pick 2 pick func-offset-27 18 pick 0 func-offset-27 22 pick 22 pick 4 pick 4 pick func-get_cell_state-24 5 pick 2 pick + 22 pick 1 func-offset-27 22 pick 0 func-offset-27 26 pick 26 pick 4 pick 4 pick func-get_cell_state-24 4 pick 2 pick + 1 0 swap - 27 pick 2 pick func-offset-27 27 pick 1 func-offset-27 31 pick 31 pick 4 pick 4 pick func-get_cell_state-24 5 pick 2 pick + 31 pick 0 func-offset-27 31 pick 1 func-offset-27 35 pick 35 pick 4 pick 4 pick func-get_cell_state-24 4 pick 2 pick + 35 pick 1 func-offset-27 35 pick 1 func-offset-27 39 pick 39 pick 4 pick 4 pick func-get_cell_state-24 4 pick 2 pick + 41 pick 41 pick 41 pick 41 pick func-get_cell_state-24 2 pick 2 < 2 pick 4 pick 3 pick 3 46 drop_range if func-on_true-33 1 skip func-on_false-34 ;
: func-on_true-41 4 pick func-idx_to_x-30 5 pick func-idx_to_y-31 5 pick 5 pick 4 pick 4 pick func-update_cell-32 1 pick 8 pick 2 swap ** * 5 pick 2 pick + 9 pick 1 + 9 pick 9 pick 4 pick 4 pick 4 14 drop_range func-compute_next_data_low-40 ;
: func-on_false-42 1 pick swap drop swap drop swap drop swap drop ;
: func-compute_next_data_low-40 1 pick 30 < 2 pick 6 pick 6 pick 6 pick 5 pick 5 10 drop_range if func-on_true-41 1 skip func-on_false-42 ;
: func-compute_next_data_low-39 2 pick 2 pick 0 0 4 6 drop_range func-compute_next_data_low-40 ;
: func-on_true-45 4 pick 30 + 1 pick func-idx_to_x-30 6 pick 30 + 1 pick func-idx_to_y-31 7 pick 7 pick 5 pick 4 pick func-update_cell-32 1 pick 10 pick 2 swap ** * 7 pick 2 pick + 11 pick 1 + 11 pick 11 pick 4 pick 4 pick 4 16 drop_range func-compute_next_data_high-44 ;
: func-on_false-46 1 pick swap drop swap drop swap drop swap drop ;
: func-compute_next_data_high-44 1 pick 30 + 1 pick 49 < 3 pick 7 pick 7 pick 7 pick 5 pick 5 11 drop_range if func-on_true-45 1 skip func-on_false-46 ;
: func-compute_next_data_high-43 2 pick 2 pick 0 0 4 6 drop_range func-compute_next_data_high-44 ;
: func-on_true-49 5 pick 5 pick 4 pick 4 pick func-get_cell_state-24 7 2 pick * 8 2 pick - 10 6 pick ** 2 pick 2 pick * 8 pick 2 pick + 8 pick 1 + 12 pick 12 pick 3 pick 11 pick 6 pick 5 17 drop_range func-make_decimal_row-48 ;
: func-on_false-50 3 pick swap drop swap drop swap drop swap drop swap drop ;
: func-make_decimal_row-48 3 pick 7 < 6 pick 6 pick 4 pick 7 pick 7 pick 6 pick 6 12 drop_range if func-on_true-49 1 skip func-on_false-50 ;
: func-make_decimal_row-47 3 pick 3 pick 0 4 pick 0 5 8 drop_range func-make_decimal_row-48 ;
: func-on_true-53 3 pick 3 pick 3 pick func-make_decimal_row-47 1 pick print 2 pick 1 + 5 pick 5 pick 3 pick func-print_game-52 drop drop drop drop drop ;
: func-print_game-52 1 pick 7 < 4 pick 4 pick 4 pick 4 pick 4 8 drop_range if func-on_true-53 3 skip drop drop drop ;
: func-print_game-51 2 pick 2 pick 0 3 5 drop_range func-print_game-52 ;
: func-game_loop-54 2 pick 2 pick func-print_game-51 0 print 0 print 0 print 2 pick 2 pick func-compute_next_data_low-39 3 pick 3 pick func-compute_next_data_high-43 1 pick 3 pick rot drop rot drop rot drop rot drop func-game_loop-54 ;

: comment Start Main ;
4 50987008 func-game_loop-54