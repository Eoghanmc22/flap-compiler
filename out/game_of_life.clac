: comment Compiled using Eoghan's flap to clac compiler https://github.com/Eoghanmc22/flap-compiler ;

: comment flap source code:
    // Conways Game of Life
    
    const int DIMENSION = 7;
    //const int LEN = DIMENSION * DIMENSION;
    const int LEN = 49;
    const int SEED_HIGH = 0b0000000000000000100;
    const int SEED_LOW = 0b000011000010100000000000000000;
    
    // Convets a logical position into a bit index
    int get_cell_index(int x, int y) {
      x + DIMENSION * y
    }
    
    // Returns the status of a cell
    // Returns 1 if the cell at index x, y is alive
    // Returns 0 otherwise
    int get_cell_state(int data_high, int data_low, int x, int y) {
      int index = get_cell_index(x, y);
    
      if (index >= 30) {
        int index = index - 30;
        (data_high >> index) & 1
      } else {
        (data_low >> index) & 1
      }
    }
    
    // Wrapping offset of logical positions
    // Adds `by` to `pos` mod `DIMENSION`
    int offset(int pos, int by) {
      if (by >= 0) {
        (pos + by) % DIMENSION
      } else {
        (pos + DIMENSION + by) % DIMENSION
      }
    }
    
    // Bit index to logical x position
    int idx_to_x(int idx) {
      idx % DIMENSION
    }
    
    // Bit index to logical y position
    int idx_to_y(int idx) {
      idx / DIMENSION
    }
    
    // Calculates the next state of a cell using the rules of Conways Game of Life
    int update_cell(int data_high, int data_low, int x, int y) {
      int neighbors = 
              get_cell_state(data_high, data_low, offset(x, -1), offset(y, -1))
              + get_cell_state(data_high, data_low, offset(x, 0), offset(y, -1))
              + get_cell_state(data_high, data_low, offset(x, 1), offset(y, -1))
              + get_cell_state(data_high, data_low, offset(x, -1), offset(y, 0))
              + get_cell_state(data_high, data_low, offset(x, 1), offset(y, 0))
              + get_cell_state(data_high, data_low, offset(x, -1), offset(y, 1))
              + get_cell_state(data_high, data_low, offset(x, 0), offset(y, 1))
              + get_cell_state(data_high, data_low, offset(x, 1), offset(y, 1));
    
      int is_alive = get_cell_state(data_high, data_low, x, y);
    
      if (neighbors < 2) {
        0
      } else if (neighbors == 2) {
        is_alive
      } else if (neighbors == 3) {
        1
      } else {
        0
      }
    }
    
    // Compute the next low order bits of the game state
    int compute_next_data_low(int last_data_high, int last_data_low) {
      int compute_next_data_low(int last_data_high, int last_data_low, int next_data_low, int idx) {
        if (idx < 30) {
          int x = idx_to_x(idx);
          int y = idx_to_y(idx);
    
          int next_data_low = next_data_low + (update_cell(last_data_high, last_data_low, x, y) << idx);
    
          compute_next_data_low(last_data_high, last_data_low, next_data_low, idx + 1)
        } else {
          next_data_low
        }
      }
    
      compute_next_data_low(last_data_high, last_data_low, 0, 0)
    }
    
    // Compute the next high order bits of the game state
    int compute_next_data_high(int last_data_high, int last_data_low) {
      int compute_next_data_high(int last_data_high, int last_data_low, int next_data_high, int idx) {
        if (idx + 30 < LEN) {
          int x = idx_to_x(idx + 30);
          int y = idx_to_y(idx + 30);
    
          int next_data_high = next_data_high + (update_cell(last_data_high, last_data_low, x, y) << idx);
    
          compute_next_data_high(last_data_high, last_data_low, next_data_high, idx + 1)
        } else {
          next_data_high
        }
      }
    
      compute_next_data_high(last_data_high, last_data_low, 0, 0)
    }
    
    // Compute the integer used to print a game row in a somewhat human readable way
    int make_decimal_row(int data_high, int data_low, int y) {
      int make_decimal_row(int data_high, int data_low, int x, int y, int row) {
        if (x < DIMENSION) {
          // int row = row + (1 + 7 * get_cell_state(data_high, data_low, x, y)) * (10 ** x);
          int row = row + (8 - 7 * get_cell_state(data_high, data_low, x, y)) * (10 ** x);
        
          make_decimal_row(data_high, data_low, x + 1, y, row)
        } else {
          row
        }
      }
    
      make_decimal_row(data_high, data_low, 0, y, 0)
    }
    
    // Print the whole game state
    void print_game(int data_high, int data_low) {
      void print_game(int data_high, int data_low, int y) {
        if (y < DIMENSION) {
          int row = make_decimal_row(data_high, data_low, y);
    
          print(row);
        
          print_game(data_high, data_low, y + 1);
        }
      }
    
      print_game(data_high, data_low, 0)
    }
    
    // The recursive game loop
    void game_loop(int data_high, int data_low) {
      print_game(data_high, data_low);
    
      // Emulate new lines
      print(0);
      print(0);
      print(0);
    
      int next_data_low = compute_next_data_low(data_high, data_low);
      int next_data_high = compute_next_data_high(data_high, data_low);
    
      // Recursion goes brrrr
      game_loop(next_data_high, next_data_low)
    }
    
    game_loop(SEED_HIGH, SEED_LOW);
;

: comment Start Definitions ;
: const-DIMENSION-0 7 ;
: const-LEN-1 49 ;
: const-SEED_HIGH-2 4 ;
: const-SEED_LOW-3 50987008 ;
: func-get_cell_index-5 const-DIMENSION-0 2 pick * 3 pick 2 pick + 1 pick swap drop swap drop swap drop swap drop ;
: func-on_true-7 2 pick 30 - 7 pick 2 pick 2 swap ** / 1 pick 0 2 pick 2 % + 1 pick swap drop swap drop swap drop swap drop ;
: func-on_false-8 5 pick 3 pick 2 swap ** / 1 pick 0 2 pick 2 % + 1 pick swap drop swap drop swap drop ;
: func-get_cell_state-6 2 pick 2 pick func-get_cell_index-5 1 2 pick 30 < - 1 pick if func-on_true-7 1 skip func-on_false-8 1 pick swap drop swap drop swap drop swap drop swap drop swap drop swap drop ;
: func-on_true-10 3 pick 3 pick + 1 pick const-DIMENSION-0 % 1 pick swap drop swap drop ;
: func-on_false-11 3 pick const-DIMENSION-0 + 1 pick 4 pick + 1 pick const-DIMENSION-0 % 1 pick swap drop swap drop swap drop ;
: func-offset-9 1 2 pick 0 < - 1 pick if func-on_true-10 1 skip func-on_false-11 1 pick swap drop swap drop swap drop swap drop ;
: func-idx_to_x-12 1 pick const-DIMENSION-0 % 1 pick swap drop swap drop ;
: func-idx_to_y-13 1 pick const-DIMENSION-0 / 1 pick swap drop swap drop ;
: func-on_true-15 0 ;
: func-on_true-17 3 pick ;
: func-on_true-19 1 ;
: func-on_false-20 0 ;
: func-on_false-18 4 pick 3 - if 0 1 skip 1 1 pick if func-on_true-19 1 skip func-on_false-20 1 pick swap drop swap drop ;
: func-on_false-16 3 pick 2 - if 0 1 skip 1 1 pick if func-on_true-17 1 skip func-on_false-18 1 pick swap drop swap drop ;
: func-update_cell-14 0 1 - 3 pick 2 pick func-offset-9 0 1 - 4 pick 2 pick func-offset-9 8 pick 8 pick 5 pick 4 pick func-get_cell_state-6 7 pick 0 func-offset-9 0 1 - 8 pick 2 pick func-offset-9 12 pick 12 pick 5 pick 4 pick func-get_cell_state-6 5 pick 2 pick + 12 pick 1 func-offset-9 0 1 - 13 pick 2 pick func-offset-9 17 pick 17 pick 5 pick 4 pick func-get_cell_state-6 5 pick 2 pick + 0 1 - 18 pick 2 pick func-offset-9 18 pick 0 func-offset-9 22 pick 22 pick 4 pick 4 pick func-get_cell_state-6 5 pick 2 pick + 22 pick 1 func-offset-9 22 pick 0 func-offset-9 26 pick 26 pick 4 pick 4 pick func-get_cell_state-6 4 pick 2 pick + 0 1 - 27 pick 2 pick func-offset-9 27 pick 1 func-offset-9 31 pick 31 pick 4 pick 4 pick func-get_cell_state-6 5 pick 2 pick + 31 pick 0 func-offset-9 31 pick 1 func-offset-9 35 pick 35 pick 4 pick 4 pick func-get_cell_state-6 4 pick 2 pick + 35 pick 1 func-offset-9 35 pick 1 func-offset-9 39 pick 39 pick 4 pick 4 pick func-get_cell_state-6 4 pick 2 pick + 41 pick 41 pick 41 pick 41 pick func-get_cell_state-6 2 pick 2 < 1 pick if func-on_true-15 1 skip func-on_false-16 1 pick swap drop swap drop swap drop swap drop swap drop swap drop swap drop swap drop swap drop swap drop swap drop swap drop swap drop swap drop swap drop swap drop swap drop swap drop swap drop swap drop swap drop swap drop swap drop swap drop swap drop swap drop swap drop swap drop swap drop swap drop swap drop swap drop swap drop swap drop swap drop swap drop swap drop swap drop swap drop swap drop swap drop swap drop swap drop swap drop ;
: func-on_true-23 2 pick func-idx_to_x-12 3 pick func-idx_to_y-13 7 pick 7 pick 4 pick 4 pick func-update_cell-14 1 pick 6 pick 2 swap ** * 7 pick 2 pick + 7 pick 1 + 11 pick 11 pick 4 pick 4 pick func-compute_next_data_low-22 1 pick swap drop swap drop swap drop swap drop swap drop swap drop swap drop ;
: func-on_false-24 3 pick ;
: func-compute_next_data_low-22 1 pick 30 < 1 pick if func-on_true-23 1 skip func-on_false-24 1 pick swap drop swap drop swap drop swap drop swap drop swap drop ;
: func-compute_next_data_low-21 2 pick 2 pick 0 0 func-compute_next_data_low-22 1 pick swap drop swap drop swap drop ;
: func-on_true-27 3 pick 30 + 1 pick func-idx_to_x-12 5 pick 30 + 1 pick func-idx_to_y-13 10 pick 10 pick 5 pick 4 pick func-update_cell-14 1 pick 9 pick 2 swap ** * 10 pick 2 pick + 10 pick 1 + 14 pick 14 pick 4 pick 4 pick func-compute_next_data_high-26 1 pick swap drop swap drop swap drop swap drop swap drop swap drop swap drop swap drop swap drop ;
: func-on_false-28 4 pick ;
: func-compute_next_data_high-26 1 pick 30 + 1 pick const-LEN-1 < 1 pick if func-on_true-27 1 skip func-on_false-28 1 pick swap drop swap drop swap drop swap drop swap drop swap drop swap drop ;
: func-compute_next_data_high-25 2 pick 2 pick 0 0 func-compute_next_data_high-26 1 pick swap drop swap drop swap drop ;
: func-on_true-31 6 pick 6 pick 6 pick 6 pick func-get_cell_state-6 7 2 pick * 8 2 pick - 10 8 pick ** 2 pick 2 pick * 7 pick 2 pick + 10 pick 1 + 13 pick 13 pick 3 pick 13 pick 6 pick func-make_decimal_row-30 1 pick swap drop swap drop swap drop swap drop swap drop swap drop swap drop swap drop ;
: func-on_false-32 2 pick ;
: func-make_decimal_row-30 3 pick const-DIMENSION-0 < 1 pick if func-on_true-31 1 skip func-on_false-32 1 pick swap drop swap drop swap drop swap drop swap drop swap drop swap drop ;
: func-make_decimal_row-29 3 pick 3 pick 0 4 pick 0 func-make_decimal_row-30 1 pick swap drop swap drop swap drop swap drop ;
: func-on_true-35 4 pick 4 pick 4 pick func-make_decimal_row-29 1 pick print 3 pick 1 + 6 pick 6 pick 3 pick func-print_game-34 drop drop ;
: func-print_game-34 1 pick const-DIMENSION-0 < 1 pick if func-on_true-35 0 skip drop drop drop drop ;
: func-print_game-33 2 pick 2 pick 0 func-print_game-34 drop drop ;
: func-game_loop-36 2 pick 2 pick func-print_game-33 0 print 0 print 0 print 2 pick 2 pick func-compute_next_data_low-21 3 pick 3 pick func-compute_next_data_high-25 1 pick 3 pick func-game_loop-36 drop drop drop drop ;

: comment Start Main ;
const-SEED_HIGH-2 const-SEED_LOW-3 func-game_loop-36